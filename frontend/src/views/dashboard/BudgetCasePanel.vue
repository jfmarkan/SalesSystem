<template>
	<div class="forecast-page">
		<Toast />

		<!-- Confirm dialog -->
		<Dialog v-model:visible="confirmVisible" :modal="true" :draggable="false" :dismissableMask="true"
			header="Ungespeicherte Änderungen" :style="{ width: '520px' }">
			<p class="mb-3 text-muted-90">Es gibt nicht gespeicherte Änderungen. Möchtest du sie speichern?</p>
			<template #footer>
				<div class="dialog-actions">
					<Button label="Abbrechen" severity="secondary" text
						@click="confirmVisible = false; pendingChange = null" />
					<Button label="Verwerfen" severity="danger" text @click="discardAndApply" />
					<Button label="Speichern" icon="pi pi-save" @click="saveAndApply" />
				</div>
			</template>
		</Dialog>

		<!-- COLUMNA IZQUIERDA - FILTROS (2/12 columnas, altura completa) -->
		<aside class="sidebar glass">
			<ForecastFilters :mode="mode" :primary-options="primaryOptions" :primary-id="primaryId"
				:secondary-options="secondaryOptionsWithDots" :secondary-id="secondaryId"
				@update:mode="(v) => guardedChange('mode', normalizeMode(v))"
				@update:primary-id="(v) => guardedChange('primary', v)"
				@update:secondary-id="(v) => guardedChange('secondary', v)" @next="handleNext" />

			<!-- Leyenda con Prime Icons -->
			<div class="legend">
				<span class="legend-item">
					<i class="pi pi-check-circle legend-icon legend-icon-done"></i>
					Vorhanden
				</span>
				<span class="legend-item">
					<i class="pi pi-circle legend-icon legend-icon-pending"></i>
					Fehlt
				</span>
			</div>

			<div class="note" v-if="loading">Lädt…</div>
		</aside>

		<!-- COLUMNA DERECHA - CONTENIDO (10/12 columnas) -->
		<div class="main-content">

			<!-- FILA 1 - TÍTULO (altura automática) -->
			<header class="topbar glass">
				<div class="title-side">
					<div class="title">
						<span class="eyebrow">Forecast</span>
						<span v-if="hasSelection" class="main-title">
							<ForecastTitle :client="selectedClientName" :kunde="selectedClientName"
								:pc="selectedPCName" />
						</span>
						<span v-else class="main-title muted">Bitte Kunde und Profit Center wählen</span>
					</div>
					<Badge v-if="hasSelection && hasCaseForSelection" value="✓ Budget Case" severity="success"
						size="small" class="ml-1" />
				</div>
				<div class="actions">
					<Button label="Speichern" icon="pi pi-save" :disabled="!budgetDirty" :outlined="!budgetDirty"
						@click="saveBudgetCase" />
				</div>
			</header>

			<!-- FILA 2 - DIAGRAMA Y CASO (altura flexible, proporción 80/20) -->
			<div class="middle-row">
				<!-- DIAGRAMA (80%) -->
				<div class="chart-container">
					<h3 class="section-title">Diagramm</h3>
					<div class="panel">
						<LineChartSmart v-if="hasSelection" type="cumulative" :client-id="currentClientId"
							:profit-center-id="currentPcId" api-prefix="/api" :auto-fetch="false"
							:cum-data="cumDataForChart" :busy="loading" />
						<div v-else class="empty">Keine Auswahl</div>
					</div>
				</div>

				<!-- CASO (20%) -->
				<div class="case-container">
					<h3 class="section-title">Budget-Fall</h3>
					<div class="panel">
						<BudgetCasePanel v-if="hasSelection" :key="`${currentClientId}-${currentPcId}`" ref="bcRef"
							:client-group-number="cgnForChild" :profit-center-code="pccForChild" :disabled="false"
							:prefill="prefillFromDb" @dirty-change="(v) => budgetDirty = !!v"
							@values-change="onChildValues" @simulated="onSimulated" />
						<div v-else class="empty">Keine Auswahl</div>
					</div>
				</div>
			</div>

			<!-- FILA 3 - TABLA (altura automática) -->
			<div class="table-container blocked">
				<h3 class="section-title">Tabelle</h3>
				<div class="panel">
					<ForecastTable v-if="hasSelection" :months="months" :ventas="sales" :budget="budget"
						:forecast="forecast" @edit-forecast="() => { }" />
					<div v-else class="empty">Keine Auswahl</div>
					<div class="overlay" aria-hidden="true" aria-label="Deaktiviert" title="Deaktiviert"></div>
				</div>
			</div>

		</div>
	</div>
</template>

<script setup>
import { ref, computed, watch, onMounted, nextTick } from 'vue'
import { useRoute, useRouter } from 'vue-router'
import Toast from 'primevue/toast'
import Dialog from 'primevue/dialog'
import Button from 'primevue/button'
import Badge from 'primevue/badge'
import { useToast } from 'primevue/usetoast'
import api from '@/plugins/axios'
import { ensureCsrf } from '@/plugins/csrf'

import ForecastTitle from '@/components/titles/ComponentTitle.vue'
import ForecastFilters from '@/components/filters/ComponentFilter.vue'
import ForecastTable from '@/components/tables/ComponentTable.vue'
import LineChartSmart from '@/components/charts/LineChartSmart.vue'
import BudgetCasePanel from '@/components/elements/BudgetCaseItem.vue'

const toast = useToast()
const route = useRoute()
const router = useRouter()

/* ---------------------------------------------------
   Master data & assignment mapping (CPC id per pair)
---------------------------------------------------- */
const clients = ref([])
const profitCenters = ref([])
const mapClientToPC = ref({})
const mapPCToClient = ref({})
const clientById = ref({})
const pcById = ref({})

const cpcByPair = ref({}) // key: "clientId-pcId" -> client_profit_center_id (number)
const pairKey = (cId, pId) => `${Number(cId)}-${Number(pId)}`
function registerCpcPair(cId, pId, cpcIdRaw) {
	const id = Number(cpcIdRaw)
	if (Number.isFinite(id) && id > 0) {
		cpcByPair.value = { ...cpcByPair.value, [pairKey(cId, pId)]: id }
	}
}

async function loadMaster() {
	await ensureCsrf()
	const [resC, resP, resM] = await Promise.all([
		api.get('/api/me/clients'),
		api.get('/api/me/profit-centers'),
		api.get('/api/me/assignments'),
	])

	clients.value = Array.isArray(resC.data) ? resC.data : []
	profitCenters.value = Array.isArray(resP.data) ? resP.data : []
	mapClientToPC.value = resM.data?.clientToPc || {}
	mapPCToClient.value = resM.data?.pcToClient || {}

	clientById.value = Object.fromEntries(clients.value.map(c => [c.id, c]))
	pcById.value = Object.fromEntries(profitCenters.value.map(p => [p.id, p]))

	// ✅ load CPC ids
	const cpcIds = resM.data?.cpcIds || []
	const cpcMap = {}
	for (const item of cpcIds) {
		const key = `${item.client_id}-${item.profit_center_id}`
		cpcMap[key] = item.client_profit_center_id
	}
	cpcByPair.value = cpcMap
}

/* ---------------------------------------------------
   Filters / selection + URL persistence
---------------------------------------------------- */
const mode = ref('') // 'client' | 'pc'
const primaryId = ref(null)
const secondaryId = ref(null)
const loading = ref(false)
const suspendGuard = ref(false)

function normalizeMode(v) {
	const s = String(v || '').toLowerCase().trim()
	if (['client', 'cliente', 'kunde'].includes(s)) return 'client'
	if (['pc', 'profit', 'profitcenter', 'profit center'].includes(s)) return 'pc'
	return ''
}
const hasSelection = computed(() => !!mode.value && primaryId.value != null && secondaryId.value != null)

const primaryOptions = computed(() => {
	if (mode.value === 'client') return clients.value.map(c => ({ label: c.name, value: c.id }))
	if (mode.value === 'pc') return profitCenters.value.map(p => ({ label: p.name, value: p.id }))
	return []
})

function syncRouteQuery() {
	const q = { ...route.query }
	if (mode.value) q.mode = mode.value; else delete q.mode
	if (primaryId.value != null) q.primaryId = String(primaryId.value); else delete q.primaryId
	if (secondaryId.value != null) q.secondaryId = String(secondaryId.value); else delete q.secondaryId
	router.replace({ query: q })
}
async function restoreSelectionFromRoute() {
	const m = normalizeMode(route.query.mode)
	const p = route.query.primaryId != null ? Number(route.query.primaryId) : null
	const s = route.query.secondaryId != null ? Number(route.query.secondaryId) : null

	suspendGuard.value = true
	try {
		if (m) mode.value = m
		if (p != null) primaryId.value = p
		if (s != null) secondaryId.value = s
		if (hasSelection.value) {
			await refreshCaseFlagsForSecondary()
			await Promise.all([loadSeries(), loadBudgetCasePrefill()])
		}
	} finally {
		suspendGuard.value = false
	}
}
watch([mode, primaryId, secondaryId], () => syncRouteQuery())

/* ---------------------------------------------------
   Fiscal year rule
---------------------------------------------------- */
function budgetYearByToday() {
	const d = new Date(), m = d.getMonth() + 1, y = d.getFullYear()
	return (m >= 4 && m <= 12) ? y + 1 : y
}
const budgetFiscalYear = ref(budgetYearByToday())

/* ---------------------------------------------------
   Current selection helpers
---------------------------------------------------- */
function toNumberSafe(...vals) {
	for (const v of vals) { const n = Number(v); if (Number.isFinite(n)) return n }
	return null
}
const currentClientId = computed(() => mode.value === 'client' ? primaryId.value : secondaryId.value)
const currentPcId = computed(() => mode.value === 'client' ? secondaryId.value : primaryId.value)

const currentCGN = computed(() => {
	const c = clientById.value[currentClientId.value]
	const v = toNumberSafe(c?.client_group_number, c?.group_number, c?.clientGroupNumber, c?.client_group)
	if (Number.isFinite(v)) return v
	const fb = Number(mode.value === 'client' ? primaryId.value : secondaryId.value)
	return Number.isFinite(fb) ? fb : null
})
const currentPCC = computed(() => {
	const p = pcById.value[currentPcId.value]
	const v = toNumberSafe(p?.profit_center_code, p?.code, p?.profitCenterCode)
	if (Number.isFinite(v)) return v
	const fb = Number(mode.value === 'client' ? secondaryId.value : primaryId.value)
	return Number.isFinite(fb) ? fb : null
})
const cgnForChild = computed(() => Number.isFinite(Number(currentCGN.value)) ? Number(currentCGN.value) : null)
const pccForChild = computed(() => Number.isFinite(Number(currentPCC.value)) ? Number(currentPCC.value) : null)

/* ---------------------------------------------------
   CPC id resolution and ready flags (✓)
---------------------------------------------------- */
function cpcIdFor(clientId, pcId) {
	const id = cpcByPair.value[pairKey(clientId, pcId)]
	const n = Number(id)
	return Number.isFinite(n) && n > 0 ? n : null
}

const hasCaseCpcSet = ref(new Set())
function addReadyCpc(id) {
	const n = Number(id)
	if (!Number.isFinite(n) || n <= 0) return
	const next = new Set(hasCaseCpcSet.value)
	next.add(n)
	hasCaseCpcSet.value = next
}

async function refreshCaseFlagsForSecondary() {
	hasCaseCpcSet.value = new Set()
	if (!mode.value || primaryId.value == null) return

	const cpcIds = []

	if (mode.value === 'client') {
		const pcIds = mapClientToPC.value[primaryId.value] || []
		for (const pcId of pcIds) {
			const cpcId = cpcIdFor(primaryId.value, pcId)
			if (Number.isFinite(cpcId) && cpcId > 0) cpcIds.push(cpcId)
		}
	} else {
		const clientIds = mapPCToClient.value[primaryId.value] || []
		for (const clientId of clientIds) {
			const cpcId = cpcIdFor(clientId, primaryId.value)
			if (Number.isFinite(cpcId) && cpcId > 0) cpcIds.push(cpcId)
		}
	}

	if (!cpcIds.length) return

	try {
		await ensureCsrf()
		const params = { fiscal_year: budgetFiscalYear.value, cpc_ids: cpcIds.join(',') }
		const { data } = await api.get('/api/budget-cases/exists', { params })
		if (data?.exists && Array.isArray(data.exists)) {
			const exists = data.exists.map(Number).filter(Number.isFinite)
			hasCaseCpcSet.value = new Set(exists)
		}
	} catch {
		const found = new Set()
		for (const cpcId of cpcIds) {
			try {
				const { data } = await api.get('/api/budget-cases', { params: { client_profit_center_id: cpcId, fiscal_year: budgetFiscalYear.value } })
				if (data?.data) found.add(cpcId)
			} catch (e) {
				if (e?.response?.status !== 404) {
					// ignore
				}
			}
		}
		hasCaseCpcSet.value = found
	}
}

/* Prefill */
const prefillFromDb = ref({ best_case: null, worst_case: null })
const savedBest = ref(0)
const savedWorst = ref(0)
async function loadBudgetCasePrefill() {
	prefillFromDb.value = { best_case: null, worst_case: null }
	savedBest.value = 0
	savedWorst.value = 0
	if (!hasSelection.value) return

	const cpcId = cpcIdFor(currentClientId.value, currentPcId.value)
	try {
		await ensureCsrf()
		if (Number.isFinite(cpcId) && cpcId > 0) {
			const { data } = await api.get('/api/budget-cases', { params: { client_profit_center_id: cpcId, fiscal_year: budgetFiscalYear.value } })
			if (data?.data) {
				const b = Number(data.data.best_case) || 0
				const w = Number(data.data.worst_case) || 0
				prefillFromDb.value = { best_case: b, worst_case: w }
				savedBest.value = b
				savedWorst.value = w
				addReadyCpc(cpcId)
			} else {
				prefillFromDb.value = { best_case: null, worst_case: null }
			}
		} else {
			const cgn = Number(cgnForChild.value), pcc = Number(pccForChild.value)
			if (Number.isFinite(cgn) && Number.isFinite(pcc)) {
				const { data } = await api.get('/api/budget-cases', { params: { client_group_number: cgn, profit_center_code: pcc, fiscal_year: budgetFiscalYear.value } })
				if (data?.data) {
					const b = Number(data.data.best_case) || 0
					const w = Number(data.data.worst_case) || 0
					prefillFromDb.value = { best_case: b, worst_case: w }
					savedBest.value = b
					savedWorst.value = w
				}
			}
		}
	} catch { }
	budgetDirty.value = false
	await nextTick()
	budgetDirty.value = false
}

const hasCaseForSelection = computed(() => {
	if (!hasSelection.value) return false
	const cpcId = cpcIdFor(currentClientId.value, currentPcId.value)
	return Number.isFinite(cpcId) && hasCaseCpcSet.value.has(cpcId)
})

/* Secondary options + icons */
const secondaryOptions = computed(() => {
	if (!mode.value || primaryId.value == null) return []
	if (mode.value === 'client') {
		const ids = mapClientToPC.value[primaryId.value] || []
		return ids.map(id => {
			const p = pcById.value[id]; if (!p) return null
			return { label: `${p.code} — ${p.name}`, value: p.id }
		}).filter(Boolean)
	} else {
		const ids = mapPCToClient.value[primaryId.value] || []
		return ids.map(id => {
			const c = clientById.value[id]; if (!c) return null
			return { label: c.name, value: c.id }
		}).filter(Boolean)
	}
})

const decoratedSecondaryOptions = computed(() => {
	const list = secondaryOptions.value
	if (!list.length || !mode.value) return list

	return list.map(opt => {
		const clientId = mode.value === 'client' ? primaryId.value : opt.value
		const pcId = mode.value === 'client' ? opt.value : primaryId.value
		const cpcId = cpcIdFor(clientId, pcId)
		const ready = Number.isFinite(cpcId) && hasCaseCpcSet.value.has(cpcId)
		return { ...opt, hasCase: ready }
	})
})

const secondaryOptionsWithDots = computed(() => {
	return decoratedSecondaryOptions.value.map(opt => {
		const iconClass = opt.hasCase ? 'pi pi-check-circle' : 'pi pi-circle'
		return { ...opt, label: `<i class="${iconClass}"></i>${opt.label}` }
	})
})

/* ---------------------------------------------------
   Series (chart/table)
---------------------------------------------------- */
function genMonths(n) {
	const out = [], base = new Date(); base.setDate(1)
	for (let i = 0; i < n; i++) {
		const d = new Date(base.getFullYear(), base.getMonth() + i, 1)
		out.push(`${d.getFullYear()}-${String(d.getMonth() + 1).padStart(2, '0')}`)
	}
	return out
}
function fillZeros(n) { return Array(n).fill(0) }

const months = ref(genMonths(18))
const sales = ref(fillZeros(18))
const budget = ref(fillZeros(18))
const forecast = ref(fillZeros(18))
const orders = ref(fillZeros(18))
const originalForecast = ref(fillZeros(12))

async function loadSeries() {
	if (!hasSelection.value) return
	loading.value = true
	try {
		await ensureCsrf()
		const clientId = mode.value === 'client' ? primaryId.value : secondaryId.value
		const profitCenterId = mode.value === 'client' ? secondaryId.value : primaryId.value
		const { data } = await api.get('/api/forecast/series', { params: { clientId, profitCenterId } })
		months.value = Array.isArray(data.months) && data.months.length ? data.months : genMonths(18)
		sales.value = Array.isArray(data.sales) && data.sales.length ? data.sales : fillZeros(18)
		budget.value = Array.isArray(data.budget) && data.budget.length ? data.budget : fillZeros(18)
		forecast.value = Array.isArray(data.forecast) && data.forecast.length ? data.forecast : fillZeros(18)
		orders.value = Array.isArray(data.orders) && data.orders.length ? data.orders : fillZeros(18)
		originalForecast.value = Array.isArray(data.forecast) ? data.forecast.slice(0, 12) : fillZeros(12)
	} finally {
		loading.value = false
	}
}

/* ---------------------------------------------------
   Chart overlays
---------------------------------------------------- */
function cumulateToLen(arr, len) {
	const out = []; let s = 0
	for (let i = 0; i < len; i++) { s += Number(arr?.[i] ?? 0); out.push(s) }
	return out
}
const overlayBest = ref([])
const overlayWorst = ref([])

function toCum(arr) { const out = []; let s = 0; for (let i = 0; i < arr.length; i++) { s += Number(arr[i] || 0); out.push(s) } return out }
function onSimulated(payload) {
	const t = Array.isArray(payload?.seriesTarget) ? payload.seriesTarget : []
	const bestC = toCum(t.map(x => Number(x?.best || 0)))
	const worstC = toCum(t.map(x => Number(x?.worst || 0)))
	const len = months.value?.length || 0
	const dest = Math.min(12, len), start = Math.max(0, len - dest)
	const B = Array(len).fill(0), W = Array(len).fill(0)
	for (let i = 0; i < dest; i++) { B[start + i] = bestC[i] ?? 0; W[start + i] = worstC[i] ?? 0 }
	overlayBest.value = B; overlayWorst.value = W
}
const liveCumData = computed(() => {
	if (!hasSelection.value) return null
	const len = months.value?.length || 0
	const salesCum = cumulateToLen(sales.value, len)
	const budgetCum = cumulateToLen(budget.value, len)
	const forecastCum = cumulateToLen(forecast.value, len)
	const fy = budgetCum.length ? Number(budgetCum[budgetCum.length - 1] || 0) : 0
	return { months: months.value || [], sales_cum: salesCum, budget_cum: budgetCum, forecast_cum: forecastCum, budget_fy_line: Array(len).fill(fy) }
})
const cumDataForChart = computed(() => {
	const base = liveCumData.value; if (!base) return null
	const out = { ...base }
	if (overlayBest.value.length === base.months.length) out.overlay_best = overlayBest.value
	if (overlayWorst.value.length === base.months.length) out.overlay_worst = overlayWorst.value
	return out
})

/* ---------------------------------------------------
   Save budget case
---------------------------------------------------- */
const bcRef = ref(null)
const budgetDirty = ref(false)
const confirmVisible = ref(false)
const pendingChange = ref(null)
const hasUnsaved = computed(() => !!budgetDirty.value)

const bestLatest = ref(0)
const worstLatest = ref(0)
const round4 = (n) => Math.round((Number(n) || 0) * 10000) / 10000

function onChildValues({ best_case, worst_case }) {
	const b = Number(best_case) || 0
	const w = Number(worst_case) || 0
	bestLatest.value = b
	worstLatest.value = w
	budgetDirty.value = (round4(b) !== round4(savedBest.value)) || (round4(w) !== round4(savedWorst.value))
}
function sanitize(v, fb = 0) { const n = Number(v); return Number.isFinite(n) ? n : (Number(fb) || 0) }

async function saveBudgetCase() {
	if (!bcRef.value) return

	const clientId = currentClientId.value
	const pcId = currentPcId.value
	const cpcId = cpcIdFor(clientId, pcId)
	const cgn = Number(cgnForChild.value)
	const pcc = Number(pccForChild.value)

	const fromChild = bcRef.value.getValues?.()
	const best = sanitize(fromChild?.best_case, bestLatest.value)
	const worst = sanitize(fromChild?.worst_case, worstLatest.value)

	try {
		await ensureCsrf()
		const payload = { fiscal_year: budgetFiscalYear.value, best_case: best, worst_case: worst }

		if (Number.isFinite(cpcId) && cpcId > 0) {
			payload.client_profit_center_id = cpcId
		} else {
			if (!Number.isFinite(cgn) || !Number.isFinite(pcc)) {
				toast.add({ severity: 'warn', summary: 'Hinweis', detail: 'Zuordnung (CGN/PCC) fehlt', life: 2500 })
				return
			}
			payload.client_group_number = cgn
			payload.profit_center_code = pcc
		}

		const { data } = await api.post('/api/budget-cases', payload, { withCredentials: true })

		const savedCpcId = Number(data?.data?.client_profit_center_id)
		if (Number.isFinite(savedCpcId) && savedCpcId > 0) {
			registerCpcPair(clientId, pcId, savedCpcId)
			addReadyCpc(savedCpcId)
		}

		savedBest.value = best
		savedWorst.value = worst
		budgetDirty.value = false
		bcRef.value?.markSaved?.()
		toast.add({ severity: 'success', summary: 'Gespeichert', detail: 'Budget Case gespeichert', life: 2200 })

		await refreshCaseFlagsForSecondary()
	} catch (e) {
		const msg = e?.response?.data?.message || e?.message || 'Speichern fehlgeschlagen'
		toast.add({ severity: 'error', summary: 'Fehler', detail: msg, life: 3000 })
		throw e
	}
}

/* ---------------------------------------------------
   Guarded changes & navigation
---------------------------------------------------- */
function clearAll() {
	months.value = genMonths(18)
	sales.value = fillZeros(18)
	budget.value = fillZeros(18)
	forecast.value = fillZeros(18)
	orders.value = fillZeros(18)
	originalForecast.value = fillZeros(12)
	overlayBest.value = []; overlayWorst.value = []
	bestLatest.value = 0; worstLatest.value = 0
	savedBest.value = 0; savedWorst.value = 0
	prefillFromDb.value = { best_case: null, worst_case: null }
	budgetDirty.value = false
	bcRef.value?.hardReset?.()
}

async function applyChange(kind, value) {
	if (kind === 'mode') {
		mode.value = value; primaryId.value = null; secondaryId.value = null; clearAll()
	} else if (kind === 'primary') {
		primaryId.value = value; secondaryId.value = null; clearAll();
		await refreshCaseFlagsForSecondary()
	} else if (kind === 'secondary') {
		secondaryId.value = value; clearAll()
	}
	await Promise.all([loadSeries(), loadBudgetCasePrefill()])
}

function guardedChange(kind, value) {
	if (suspendGuard.value) { applyChange(kind, value); return }
	if (hasUnsaved.value) {
		pendingChange.value = { kind, value }
		confirmVisible.value = true
	} else {
		applyChange(kind, value)
	}
}
async function saveAndApply() {
	try { if (hasUnsaved.value) await saveBudgetCase() }
	finally {
		confirmVisible.value = false
		if (pendingChange.value) await applyChange(pendingChange.value.kind, pendingChange.value.value)
		pendingChange.value = null
		bcRef.value?.hardReset?.()
	}
}
async function discardAndApply() {
	bcRef.value?.hardReset?.()
	budgetDirty.value = false
	confirmVisible.value = false
	if (pendingChange.value) await applyChange(pendingChange.value.kind, pendingChange.value.value)
	pendingChange.value = null
}
function handleNext() {
	const list = secondaryOptions.value; if (!list?.length) return
	const idx = list.findIndex(o => o.value === secondaryId.value)
	const n = (idx >= 0 ? idx + 1 : 0) % list.length
	guardedChange('secondary', list[n].value)
}

/* ---------------------------------------------------
   Watches / lifecycle
---------------------------------------------------- */
watch([mode, primaryId], () => {
	if (primaryId.value != null) refreshCaseFlagsForSecondary()
})
watch(secondaryId, () => { loadSeries(); loadBudgetCasePrefill() })

onMounted(async () => {
	budgetFiscalYear.value = budgetYearByToday()
	await loadMaster()
	await restoreSelectionFromRoute()
	if (primaryId.value) await refreshCaseFlagsForSecondary()
})

/* ---------------------------------------------------
   Header labels
---------------------------------------------------- */
const selectedClientName = computed(() => {
	if (mode.value === 'client') return clientById.value[primaryId.value]?.name || ''
	return clientById.value[secondaryId.value]?.name || ''
})
const selectedPCName = computed(() => {
	const pcId = mode.value === 'client' ? secondaryId.value : primaryId.value
	const p = pcById.value[pcId]
	return p ? `${p.name}` : ''
})
</script>

<style scoped>
:root {
	--bg: var(--p-surface-ground, #f6f7f9);
	--surface: var(--p-surface-card, #ffffff);
	--text: var(--p-text-color, #111827);
	--muted: var(--p-text-muted-color, #6b7280);
	--border: var(--p-content-border-color, #e5e7eb);
	--ok-bg: color-mix(in lab, var(--p-green-500) 12%, transparent);
	--ok-text: var(--p-green-600, #0e7a3e);
	--ok-border: color-mix(in lab, var(--p-green-500), transparent 60%);
	--shadow: var(--p-shadow-2, 0 8px 24px rgba(0, 0, 0, 0.06));
}

@media (prefers-color-scheme: dark) {
	:root {
		--bg: var(--p-surface-ground, #0b1020);
		--surface: var(--p-surface-card, #12182a);
		--text: var(--p-text-color, #e5e7eb);
		--muted: var(--p-text-muted-color, #9aa3b2);
		--border: var(--p-content-border-color, #1f2937);
		--ok-bg: color-mix(in oklab, var(--p-green-400) 20%, transparent);
		--ok-text: var(--p-green-300, #8ce0ae);
		--ok-border: color-mix(in oklab, var(--p-green-400), transparent 60%);
		--shadow: var(--p-shadow-6, 0 10px 28px rgba(0, 0, 0, 0.35));
	}
}

/* GRID ORIGINAL INTACTO */
.forecast-page {
	display: grid;
	grid-template-columns: 2fr 10fr;
	grid-template-rows: 100vh;
	gap: 16px;
	padding: 16px;
	color: var(--text);
	box-sizing: border-box;
	background: var(--bg);
}

.sidebar {
	grid-column: 1;
	grid-row: 1;
	display: flex;
	flex-direction: column;
	background: var(--surface);
	border: 1px solid var(--border);
	border-radius: 16px;
	box-shadow: var(--shadow);
	padding: 18px;
	overflow-y: auto;
	transition: background .2s, border-color .2s, box-shadow .2s;
}

.main-content {
	grid-column: 2;
	grid-row: 1;
	display: grid;
	grid-template-rows: auto 1fr auto;
	gap: 16px;
	height: 100%;
	min-height: 0;
}

.topbar {
	grid-row: 1;
	display: flex;
	align-items: center;
	justify-content: space-between;
	padding: 14px 18px;
	background: var(--surface);
	border: 1px solid var(--border);
	border-radius: 16px;
	box-shadow: var(--shadow);
	position: sticky;
	top: 0;
	z-index: 1;
}

.title-side {
	display: flex;
	align-items: center;
	gap: 12px;
}

.eyebrow {
	font-size: 12px;
	color: var(--muted);
	text-transform: uppercase;
	letter-spacing: .06em;
}

.main-title {
	font-weight: 600;
	font-size: 16px;
}

.muted {
	color: var(--muted);
}

.actions {
	display: flex;
	gap: 8px;
}

.middle-row {
	grid-row: 2;
	display: grid;
	grid-template-columns: 8fr 2fr;
	gap: 16px;
	min-height: 0;
}

.chart-container,
.case-container {
	background: var(--surface);
	border: 1px solid var(--border);
	border-radius: 16px;
	box-shadow: var(--shadow);
	padding: 18px;
	display: flex;
	flex-direction: column;
	min-height: 0;
	transition: background .2s, border-color .2s, box-shadow .2s;
}

.table-container {
	grid-row: 3;
	background: var(--surface);
	border: 1px solid var(--border);
	border-radius: 16px;
	box-shadow: var(--shadow);
	padding: 18px;
	position: relative;
	display: flex;
	flex-direction: column;
}

.panel {
	flex: 1;
	display: flex;
	flex-direction: column;
	min-height: 0;
	background: color-mix(in oklab, var(--surface), transparent 6%);
	border-radius: 12px;
}

.panel>* {
	flex: 1;
}

.section-title {
	margin: 0 0 12px 0;
	font-size: 16px;
	font-weight: 600;
	color: var(--text);
}

.empty {
	color: var(--muted);
	font-size: 14px;
	padding: 8px;
	display: flex;
	align-items: center;
	justify-content: center;
	flex: 1;
}

.blocked {
	position: relative;
}

.blocked .overlay {
	position: absolute;
	inset: 0;
	cursor: not-allowed;
	z-index: 2;
	border-radius: 12px;
	background: color-mix(in oklab, var(--surface), transparent 70%);
	backdrop-filter: blur(1px) saturate(1.05);
}

.dialog-actions {
	display: flex;
	justify-content: flex-end;
	gap: 8px;
}

/* Leyenda */
.legend {
	margin-top: 12px;
	display: flex;
	flex-direction: column;
	gap: 8px;
	font-size: 13px;
}

.legend-item {
	display: flex;
	align-items: center;
	gap: 6px;
	color: var(--text);
}

.legend-icon {
	font-size: 12px;
	flex-shrink: 0;
}

.legend-icon-done {
	color: var(--p-green-500, #10b981);
}

.legend-icon-pending {
	color: var(--p-surface-500, #9ca3af);
}

/* Iconos Prime en Listbox */
:deep(.p-listbox-item i.pi-check-circle) {
	color: var(--p-green-500, #10b981) !important;
	margin-right: 8px;
	font-size: 12px;
}

:deep(.p-listbox-item i.pi-circle) {
	color: var(--p-surface-500, #9ca3af) !important;
	margin-right: 8px;
	font-size: 12px;
}

@media (prefers-color-scheme: dark) {
	.legend-icon-pending {
		color: var(--p-surface-400, #6b7280);
	}

	:deep(.p-listbox-item i.pi-circle) {
		color: var(--p-surface-400, #6b7280) !important;
	}
}

@media (max-width: 1200px) {
	.forecast-page {
		grid-template-columns: 1fr;
		grid-template-rows: auto 1fr;
	}

	.sidebar {
		grid-column: 1;
		grid-row: 1;
		height: auto;
	}

	.main-content {
		grid-column: 1;
		grid-row: 2;
	}

	.middle-row {
		grid-template-columns: 1fr;
		grid-template-rows: 1fr auto;
	}
}

.glass {
	background: color-mix(in oklab, var(--surface), transparent 6%);
	border: 1px solid color-mix(in oklab, var(--border), transparent 15%);
	backdrop-filter: saturate(1.1) blur(6px);
}
</style>
